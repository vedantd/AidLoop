import {
  __commonJS
} from "./chunk-LK32TJAX.js";

// node_modules/@stellar/freighter-api/build/index.min.js
var require_index_min = __commonJS({
  "node_modules/@stellar/freighter-api/build/index.min.js"(exports, module) {
    !function(r, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.freighterApi = e() : r.freighterApi = e();
    }(exports, () => (() => {
      "use strict";
      var r, e, s = { d: (r2, e2) => {
        for (var t2 in e2) s.o(e2, t2) && !s.o(r2, t2) && Object.defineProperty(r2, t2, { enumerable: true, get: e2[t2] });
      }, o: (r2, e2) => Object.prototype.hasOwnProperty.call(r2, e2), r: (r2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(r2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r2, "__esModule", { value: true });
      } }, t = {};
      s.r(t), s.d(t, { WatchWalletChanges: () => u, addToken: () => S, default: () => D, getAddress: () => _, getNetwork: () => C, getNetworkDetails: () => O, isAllowed: () => R, isBrowser: () => U, isConnected: () => N, requestAccess: () => w, setAllowed: () => I, signAuthEntry: () => l, signMessage: () => c, signTransaction: () => d }), function(r2) {
        r2.CREATE_ACCOUNT = "CREATE_ACCOUNT", r2.FUND_ACCOUNT = "FUND_ACCOUNT", r2.ADD_ACCOUNT = "ADD_ACCOUNT", r2.IMPORT_ACCOUNT = "IMPORT_ACCOUNT", r2.IMPORT_HARDWARE_WALLET = "IMPORT_HARDWARE_WALLET", r2.LOAD_ACCOUNT = "LOAD_ACCOUNT", r2.MAKE_ACCOUNT_ACTIVE = "MAKE_ACCOUNT_ACTIVE", r2.UPDATE_ACCOUNT_NAME = "UPDATE_ACCOUNT_NAME", r2.GET_MNEMONIC_PHRASE = "GET_MNEMONIC_PHRASE", r2.CONFIRM_MNEMONIC_PHRASE = "CONFIRM_MNEMONIC_PHRASE", r2.CONFIRM_MIGRATED_MNEMONIC_PHRASE = "CONFIRM_MIGRATED_MNEMONIC_PHRASE", r2.RECOVER_ACCOUNT = "RECOVER_ACCOUNT", r2.CONFIRM_PASSWORD = "CONFIRM_PASSWORD", r2.REJECT_ACCESS = "REJECT_ACCESS", r2.GRANT_ACCESS = "GRANT_ACCESS", r2.ADD_TOKEN = "ADD_TOKEN", r2.SIGN_TRANSACTION = "SIGN_TRANSACTION", r2.SIGN_BLOB = "SIGN_BLOB", r2.SIGN_AUTH_ENTRY = "SIGN_AUTH_ENTRY", r2.HANDLE_SIGNED_HW_PAYLOAD = "HANDLE_SIGNED_HW_PAYLOAD", r2.REJECT_TRANSACTION = "REJECT_TRANSACTION", r2.SIGN_FREIGHTER_TRANSACTION = "SIGN_FREIGHTER_TRANSACTION", r2.SIGN_FREIGHTER_SOROBAN_TRANSACTION = "SIGN_FREIGHTER_SOROBAN_TRANSACTION", r2.ADD_RECENT_ADDRESS = "ADD_RECENT_ADDRESS", r2.LOAD_RECENT_ADDRESSES = "LOAD_RECENT_ADDRESSES", r2.LOAD_LAST_USED_ACCOUNT = "LOAD_LAST_USED_ACCOUNT", r2.SIGN_OUT = "SIGN_OUT", r2.SHOW_BACKUP_PHRASE = "SHOW_BACKUP_PHRASE", r2.SAVE_ALLOWLIST = "SAVE_ALLOWLIST", r2.SAVE_SETTINGS = "SAVE_SETTINGS", r2.SAVE_EXPERIMENTAL_FEATURES = "SAVE_EXPERIMENTAL_FEATURES", r2.LOAD_SETTINGS = "LOAD_SETTINGS", r2.GET_CACHED_ASSET_ICON = "GET_CACHED_ASSET_ICON", r2.CACHE_ASSET_ICON = "CACHE_ASSET_ICON", r2.GET_CACHED_ASSET_DOMAIN = "GET_CACHED_ASSET_DOMAIN", r2.CACHE_ASSET_DOMAIN = "CACHE_ASSET_DOMAIN", r2.GET_MEMO_REQUIRED_ACCOUNTS = "GET_MEMO_REQUIRED_ACCOUNTS", r2.ADD_CUSTOM_NETWORK = "ADD_CUSTOM_NETWORK", r2.CHANGE_NETWORK = "CHANGE_NETWORK", r2.REMOVE_CUSTOM_NETWORK = "REMOVE_CUSTOM_NETWORK", r2.EDIT_CUSTOM_NETWORK = "EDIT_CUSTOM_NETWORK", r2.RESET_EXP_DATA = "RESET_EXP_DATA", r2.ADD_TOKEN_ID = "ADD_TOKEN_ID", r2.GET_TOKEN_IDS = "GET_TOKEN_IDS", r2.REMOVE_TOKEN_ID = "REMOVE_TOKEN_ID", r2.GET_MIGRATABLE_ACCOUNTS = "GET_MIGRATABLE_ACCOUNTS", r2.GET_MIGRATED_MNEMONIC_PHRASE = "GET_MIGRATED_MNEMONIC_PHRASE", r2.MIGRATE_ACCOUNTS = "MIGRATE_ACCOUNTS", r2.ADD_ASSETS_LIST = "ADD_ASSETS_LIST", r2.MODIFY_ASSETS_LIST = "MODIFY_ASSETS_LIST", r2.CHANGE_ASSET_VISIBILITY = "CHANGE_ASSET_VISIBILITY", r2.GET_HIDDEN_ASSETS = "GET_HIDDEN_ASSETS", r2.GET_IS_ACCOUNT_MISMATCH = "GET_IS_ACCOUNT_MISMATCH";
      }(r || (r = {})), function(r2) {
        r2.REQUEST_ACCESS = "REQUEST_ACCESS", r2.REQUEST_PUBLIC_KEY = "REQUEST_PUBLIC_KEY", r2.SUBMIT_TOKEN = "SUBMIT_TOKEN", r2.SUBMIT_TRANSACTION = "SUBMIT_TRANSACTION", r2.SUBMIT_BLOB = "SUBMIT_BLOB", r2.SUBMIT_AUTH_ENTRY = "SUBMIT_AUTH_ENTRY", r2.REQUEST_NETWORK = "REQUEST_NETWORK", r2.REQUEST_NETWORK_DETAILS = "REQUEST_NETWORK_DETAILS", r2.REQUEST_CONNECTION_STATUS = "REQUEST_CONNECTION_STATUS", r2.REQUEST_ALLOWED_STATUS = "REQUEST_ALLOWED_STATUS", r2.SET_ALLOWED_STATUS = "SET_ALLOWED_STATUS", r2.REQUEST_USER_INFO = "REQUEST_USER_INFO";
      }(e || (e = {}));
      const n = (r2) => {
        const s2 = Date.now() + Math.random();
        return window.postMessage({ source: "FREIGHTER_EXTERNAL_MSG_REQUEST", messageId: s2, ...r2 }, window.location.origin), new Promise((t2) => {
          let n2 = 0;
          r2.type !== e.REQUEST_CONNECTION_STATUS && r2.type !== e.REQUEST_PUBLIC_KEY || (n2 = setTimeout(() => {
            t2({ isConnected: false, publicKey: "" }), window.removeEventListener("message", o2);
          }, 2e3));
          const o2 = (r3) => {
            var e2, E2;
            r3.source === window && "FREIGHTER_EXTERNAL_MSG_RESPONSE" === (null === (e2 = null == r3 ? void 0 : r3.data) || void 0 === e2 ? void 0 : e2.source) && (null === (E2 = null == r3 ? void 0 : r3.data) || void 0 === E2 ? void 0 : E2.messagedId) === s2 && (t2(r3.data), window.removeEventListener("message", o2), clearTimeout(n2));
          };
          window.addEventListener("message", o2, false);
        });
      }, o = { code: -1, message: "Node environment is not supported" }, E = { code: -1, message: "The wallet encountered an internal error. Please try again or contact the wallet if the problem persists." }, T = async () => {
        let r2;
        try {
          r2 = await n({ type: e.REQUEST_ACCESS });
        } catch (r3) {
          console.error(r3);
        }
        const { publicKey: s2 } = r2 || { publicKey: "" };
        return { publicKey: s2, error: null == r2 ? void 0 : r2.apiError };
      }, A = async () => {
        let r2;
        try {
          r2 = await n({ type: e.REQUEST_PUBLIC_KEY });
        } catch (r3) {
          console.error(r3);
        }
        return { publicKey: (null == r2 ? void 0 : r2.publicKey) || "", error: null == r2 ? void 0 : r2.apiError };
      }, a = async () => {
        let r2;
        try {
          r2 = await n({ type: e.REQUEST_NETWORK_DETAILS });
        } catch (r3) {
          console.error(r3);
        }
        const { networkDetails: s2, apiError: t2 } = r2 || { networkDetails: { network: "", networkName: "", networkUrl: "", networkPassphrase: "", sorobanRpcUrl: void 0, apiError: "" } }, { network: o2, networkUrl: E2, networkPassphrase: T2, sorobanRpcUrl: A2 } = s2;
        return { network: o2, networkUrl: E2, networkPassphrase: T2, sorobanRpcUrl: A2, error: t2 };
      }, i = async () => {
        let r2;
        try {
          r2 = await n({ type: e.REQUEST_ALLOWED_STATUS });
        } catch (r3) {
          console.error(r3);
        }
        const { isAllowed: s2 } = r2 || { isAllowed: false };
        return { isAllowed: s2, error: null == r2 ? void 0 : r2.apiError };
      }, _ = async () => {
        let r2 = "";
        if (U) {
          const e2 = await A();
          return r2 = e2.publicKey, e2.error ? { address: r2, error: e2.error } : { address: r2 };
        }
        return { address: r2, error: o };
      }, S = async (r2) => {
        if (U) {
          const s2 = await (async (r3) => {
            let s3;
            try {
              s3 = await n({ contractId: r3.contractId, networkPassphrase: r3.networkPassphrase, type: e.SUBMIT_TOKEN });
            } catch (r4) {
              return { error: E };
            }
            return { contractId: s3.contractId, error: null == s3 ? void 0 : s3.apiError };
          })(r2);
          return s2.error ? { contractId: "", error: s2.error } : { contractId: s2.contractId || "" };
        }
        return { contractId: "", error: o };
      }, d = async (r2, s2) => {
        if (U) {
          const t2 = await (async (r3, s3) => {
            let t3, o2, T2, A2;
            "object" == typeof s3 ? (o2 = s3.accountToSign, T2 = s3.networkPassphrase) : (t3 = s3, o2 = void 0);
            try {
              A2 = await n({ transactionXdr: r3, network: t3, networkPassphrase: T2, accountToSign: o2, type: e.SUBMIT_TRANSACTION });
            } catch (r4) {
              return { signedTransaction: "", signerAddress: "", error: E };
            }
            const { signedTransaction: a2, signerAddress: i2 } = A2;
            return { signedTransaction: a2, signerAddress: i2, error: null == A2 ? void 0 : A2.apiError };
          })(r2, s2);
          return t2.error ? { signedTxXdr: "", signerAddress: "", error: t2.error } : { signedTxXdr: t2.signedTransaction, signerAddress: t2.signerAddress };
        }
        return { signedTxXdr: "", signerAddress: "", error: o };
      }, c = async (r2, s2) => {
        if (U) {
          const { isAllowed: t2 } = await i();
          if (!t2) {
            const r3 = await T();
            if (r3.error) return { signedMessage: null, signerAddress: "", error: r3.error };
          }
          const o2 = await (async (r3, s3, t3) => {
            let o3;
            const T2 = (t3 || {}).address;
            try {
              o3 = await n({ blob: r3, accountToSign: T2, apiVersion: "5.0.0", networkPassphrase: null == t3 ? void 0 : t3.networkPassphrase, type: e.SUBMIT_BLOB });
            } catch (r4) {
              return { signedMessage: null, signerAddress: "", error: E };
            }
            const { signedBlob: A2, signerAddress: a2 } = o3;
            return { signedMessage: A2 || null, signerAddress: a2, error: null == o3 ? void 0 : o3.apiError };
          })(r2, 0, s2);
          return o2.error ? { signedMessage: null, signerAddress: "", error: o2.error } : { signedMessage: o2.signedMessage, signerAddress: o2.signerAddress };
        }
        return { signedMessage: null, signerAddress: "", error: o };
      }, l = async (r2, s2) => {
        if (U) {
          const { isAllowed: t2 } = await i();
          if (!t2) {
            const r3 = await T();
            if (r3.error) return { signedAuthEntry: null, signerAddress: "", error: r3.error };
          }
          const o2 = await (async (r3, s3, t3) => {
            const o3 = (t3 || {}).address;
            let T2;
            try {
              T2 = await n({ entryXdr: r3, accountToSign: o3, apiVersion: "5.0.0", networkPassphrase: null == t3 ? void 0 : t3.networkPassphrase, type: e.SUBMIT_AUTH_ENTRY });
            } catch (r4) {
              return console.error(r4), { signedAuthEntry: null, signerAddress: "", error: E };
            }
            const { signedAuthEntry: A2, signerAddress: a2 } = T2;
            return { signedAuthEntry: A2 || null, signerAddress: a2, error: null == T2 ? void 0 : T2.apiError };
          })(r2, 0, s2);
          return o2.error ? { signedAuthEntry: null, signerAddress: "", error: o2.error } : { signedAuthEntry: o2.signedAuthEntry, signerAddress: o2.signerAddress };
        }
        return { signedAuthEntry: null, signerAddress: "", error: o };
      }, N = async () => U ? window.freighter ? Promise.resolve({ isConnected: window.freighter }) : (async () => {
        let r2 = { isConnected: false };
        try {
          r2 = await n({ type: e.REQUEST_CONNECTION_STATUS });
        } catch (r3) {
          console.error(r3);
        }
        return { isConnected: r2.isConnected };
      })() : { isConnected: false, error: o }, C = async () => {
        if (U) {
          const r2 = await (async () => {
            let r3;
            try {
              r3 = await n({ type: e.REQUEST_NETWORK_DETAILS });
            } catch (r4) {
              console.error(r4);
            }
            const { networkDetails: s2 } = r3 || { networkDetails: { network: "", networkPassphrase: "" } };
            return { network: null == s2 ? void 0 : s2.network, networkPassphrase: null == s2 ? void 0 : s2.networkPassphrase, error: null == r3 ? void 0 : r3.apiError };
          })();
          return r2.error ? { network: "", networkPassphrase: "", error: r2.error } : { network: r2.network, networkPassphrase: r2.networkPassphrase };
        }
        return { network: "", networkPassphrase: "", error: o };
      }, O = async () => {
        if (U) {
          const r2 = await a();
          return r2.error ? { network: "", networkUrl: "", networkPassphrase: "", error: r2.error } : { network: r2.network, networkUrl: r2.networkUrl, networkPassphrase: r2.networkPassphrase, sorobanRpcUrl: r2.sorobanRpcUrl };
        }
        return { network: "", networkUrl: "", networkPassphrase: "", error: o };
      }, R = async () => {
        let r2 = false;
        if (U) {
          const e2 = await i();
          return r2 = e2.isAllowed, e2.error ? { isAllowed: r2, error: e2.error } : { isAllowed: r2 };
        }
        return { isAllowed: r2, error: o };
      }, I = async () => {
        let r2 = false;
        if (U) {
          const s2 = await (async () => {
            let r3;
            try {
              r3 = await n({ type: e.SET_ALLOWED_STATUS });
            } catch (r4) {
              console.error(r4);
            }
            const { isAllowed: s3 } = r3 || { isAllowed: false };
            return { isAllowed: s3, error: null == r3 ? void 0 : r3.apiError };
          })();
          return r2 = s2.isAllowed, s2.error ? { isAllowed: r2, error: s2.error } : { isAllowed: r2 };
        }
        return { isAllowed: r2, error: o };
      }, w = async () => {
        let r2 = "";
        if (U) {
          const e2 = await T();
          return r2 = e2.publicKey, e2.error ? { address: r2, error: e2.error } : { address: r2 };
        }
        return { address: r2, error: o };
      };
      class u {
        constructor(r2 = 3e3) {
          this.fetchInfo = async (r3) => {
            if (!this.isRunning) return;
            const e2 = await A(), s2 = await a();
            (e2.error || s2.error) && r3({ address: "", network: "", networkPassphrase: "", error: e2.error || s2.error }), this.currentAddress === e2.publicKey && this.currentNetwork === s2.network && this.currentNetworkPassphrase === s2.networkPassphrase || (this.currentAddress = e2.publicKey, this.currentNetwork = s2.network, this.currentNetworkPassphrase = s2.networkPassphrase, r3({ address: e2.publicKey, network: s2.network, networkPassphrase: s2.networkPassphrase })), setTimeout(() => this.fetchInfo(r3), this.timeout);
          }, this.timeout = r2, this.currentAddress = "", this.currentNetwork = "", this.currentNetworkPassphrase = "", this.isRunning = false;
        }
        watch(r2) {
          return U ? (this.isRunning = true, this.fetchInfo(r2), {}) : { error: o };
        }
        stop() {
          this.isRunning = false;
        }
      }
      const U = "undefined" != typeof window, D = { getAddress: _, addToken: S, signTransaction: d, signMessage: c, signAuthEntry: l, isConnected: N, getNetwork: C, getNetworkDetails: O, isAllowed: R, setAllowed: I, requestAccess: w, WatchWalletChanges: u };
      return t;
    })());
  }
});

export {
  require_index_min
};
//# sourceMappingURL=chunk-3VMQQTJY.js.map
